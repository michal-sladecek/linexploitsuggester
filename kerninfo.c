#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include "print.h"
#include "kerninfo.h"

int mmap_min_addr = 0;
int readable_kallsyms = 0;
int kern_x64= 0;
int kern_version, kern_major, kern_minor;
char release_info[256];
int kern_processor_num;

struct utsname uname_info;


int is_word_in_command(char * cmd, char * word){
  FILE *fptr;
  char buf[1024];
  fptr = popen(cmd,"r");
  if(fptr == NULL) return 0;  
  int retval = 0;
  while(fgets(buf, sizeof(buf)-1,fptr) != NULL){
    if(strstr(buf,word) != NULL)retval = 1;
  }
  pclose(fptr);
  return retval;
}

int is_word_in_file(char * filename, char * word){
  // First determine mounted filesystems
  FILE * fptr;
  fptr = fopen(filename, "r");
  if(fptr == NULL) return 0;
  fseek(fptr,0L,SEEK_END);
  int size = ftell(fptr);
  rewind(fptr);
  char * buf = malloc(size+1);
  buf[size] = 0;
  fread(buf, size,1,fptr);
  fclose(fptr);
  if(strstr(buf, word) != NULL) return 1;
  free(buf);
  return 0;
}

void determine_mmap_min_addr(){
  // mmap_min_addr mitigates against exploits which exploit NULL ptr dereference
  // Some exploits can bypass this though
  FILE * fptr;
  fptr = fopen("/proc/sys/vm/mmap_min_addr", "r");
  if(fptr == NULL){
    mmap_min_addr = 0;
  }
  fscanf(fptr,"%d", &mmap_min_addr);
  fclose(fptr);
}

void determine_readable_kallsyms(){
  // Some exploits need kallsyms file to be readable.
  // After commit https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=455cd5ab305c90ffc422dd2e0fb634730942b257,
  // the kallsyms is readable but contains only zeroes, which also
  // mitigates against those exploits.

  FILE * fptr;
  fptr = fopen("/proc/kallsyms", "r");
  if(fptr == NULL){
    fptr = fopen("/proc/ksyms", "r");
    if(fptr == NULL){
      readable_kallsyms = 0;
      return;
    }
  }
  // We go through the kallsyms file, if we find one pointer which is non zero
  // we return that kallsyms might be used.
  for(int i=0;i<100;++i){
    char sname[256];
    char dummy;
    void * ptr;
    if(fscanf(fptr,"%p %c %s", &ptr, &dummy, sname) == EOF){
      break;
    }
    if(ptr != NULL){
      readable_kallsyms = 1;
      break;
    }
  }
  fclose(fptr);
}

void getMachineInfo(){
  uname(&uname_info);
  if(strstr(uname_info.machine,"64") != NULL) kern_x64 = 1;
  else kern_x64 = 0;
  sscanf(uname_info.release, " %d.%d.%d", &kern_version, &kern_major, &kern_minor);

  /*
   * Kernel preemption was introduced in 2.6 - that means kernels before 2.4
   * needed multiple cores for race conditions.
   * Theoreticaly speaking, we could check for CONFIG_PREEMPT settings,
   * however this would be way more difficult as there are many preemption
   * checks, and MOST of machines above 2.6 are configured for preemptive
   * kernel.
   */
  kern_processor_num = sysconf(_SC_NPROCESSORS_ONLN);
  
}

void init_info(){
  getMachineInfo();

  determine_mmap_min_addr();
  determine_readable_kallsyms();

}

void print_info(){
  if(mmap_min_addr != 0){
    printRed("mmap_min_addr is in use.\n");
    printf("\tHowever, on many kernels there are possible bypasses - for example https://blog.cr0.org/2009/06/bypassing-linux-null-pointer.html\n");
  }
  else printGreen("mmap_min_addr is not in use.\n");
  if(readable_kallsyms) printGreen("Exploits can use kallsyms\n");
  else{
    printRed("Exploits cannot use kallsyms.\n");
    printf("\tIf your exploit can use /boot/System.map, it might work though\n");
  }

  printf("Kernel: %d.%d.%d %dbit\n",kern_version,kern_major,kern_minor, (kern_x64==1)?64:32);
  printf("There are %d processors on this CPU.\n", kern_processor_num);
}
