#include <sys/socket.h>
#include <sys/ioctl.h>
#include <linux/xfrm.h>
#include <linux/netlink.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <netinet/ip.h>
#include <sys/types.h>
#include <fcntl.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdio.h>
#include "print.h"
#include "kerninfo.h"

#define REGISTER_EXPLOIT(NAME) if(exploit_ ## NAME ## _test() == 1){ printGreen("[+]"); exploit_ ##NAME ## _info();}

extern int readable_kallsyms,kern_version, kern_major, kern_minor, mmap_min_addr, kern_processor_num, kern_x64;



#include "./generated_exploits.c"


int exploit_sock_sendpage_test(){
  if(kern_version == 2 && ((kern_major == 4 && kern_minor >= 4 && kern_minor <=37) || (kern_major == 6 && kern_minor >= 0 && kern_minor <=30 ))){
    int fd;
    if((fd = socket(PF_BLUETOOTH, SOCK_DGRAM, 0)) == -1){
      if((fd=socket(PF_APPLETALK,SOCK_DGRAM,0))==-1){
        return 0;
      }
    }
    close(fd);
    return 1;
  }
  return 0;
}

void exploit_sock_sendpage_info(){
  printf("sock_sendpage exploit might be possible\n");
  printf("\tMSF module:\texploit/linux/local/sock_sendpage\n");
  printf("\tEDB exploits:\t9435,9436, 9545,9479\n");
  printf("\tKeywords:\twunderbar_emporium, CVE-2009-2692\n");
  if(mmap_min_addr != 0){
    printf("\tExploit claimes to be able to bypass NULL page protection, but it might not.\n");
    printf("\t9435 byasses null page protection when pulseaudio is installed.\n");
  }
}



int exploit_full_nelson_test(){
  if(kern_version==2 && kern_major==6 && kern_minor>=31 && kern_minor <= 37)
  {
    int fd;
    if((fd = socket(PF_ECONET, SOCK_DGRAM, 0)) == -1){
        return 0;
    }
    close(fd);
    return 1;
  }
  return 0;
}
void exploit_full_nelson_info(){
  printf("full_nelson exploit might be possible\n");
  printf("\tEDB exploits:\t15704\n");
  printf("\tKeywords: CVE-2010-3849,CVE-2010-3850,CVE-2010-4258\n");
}


int exploit_dirty_cow_test(){
  if(kern_version==2 && kern_major>=6 && kern_minor>=22){
    return 1;
  }
  if(kern_version==3 && kern_major<=9){
    return 1;
  }
  return 0;
}

void exploit_dirty_cow_info(){
  printf("dirty_cow exploit might be possible\n");
  printf("\tEDB exploits:\t40839,40616,40847\n");
  printf("\tKeywords: CVE-2016-5195\n");
}


int exploit_pipe_c_test(){
  if(kern_processor_num > 1 && kern_version==2 && kern_major==4 && kern_minor>=4 && kern_minor <= 37){
      return 1;
  }
  if(kern_version==2 && kern_major==6 && kern_minor >= 10 && kern_minor <= 31){
    return 1;
  }
  return 0;
}
void exploit_pipe_c_info(){
  printf("pipe.c exploit might be possible\n");
  printf("\tEDB exploits: 40812,33322\n");
  printf("\tYou need to use enlightement framework for 40812 though - (https://github.com/packetforger/localroot/tree/master/third-party/enlightenment)\n");
  printf("\tKeywords: CVE-2009-3547\n");
  if(mmap_min_addr != 0){
    printf("\tEDB 40812 might bypass mmap_min_addr\n");
    printf("\tDon\'t use 33322, cant mmap null page.\n");
  }
}

int exploit_CVE_2017_1000112_test(){
  if(kern_version==4 && (kern_major==4 || kern_major==8)){
    return 1;
  }
  return 0;
}
void exploit_CVE_2017_1000112_info(){
  printf("CVE_2017_1000112 might be possible\n");
  printf("\tExploit: https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-1000112/poc.c\n");
  printf("\tHowever, only trusty 4.4.0-21 - 4.4.0-83, and xenial 4.8.0-34 - 4.8.0-58\n");
}

int exploit_reiserfs_xattr_test(){
  if(kern_version==2 && kern_major==6 && ( is_word_in_file("/etc/fstab", "reiserfs") || is_word_in_file("/proc/mounts", "reiserfs"))){
    return 1;
  }
  return 0;
}

void exploit_reiserfs_xattr_info(){
  printf("Reiserfs xattr exploit might be possible\n");
  printf("\tEDB exploit: 12130\n");
  printf("\tKeywords: CVE-2010-1146\n");
  printf("\tBe sure to read the code and possibly mount the reiserfs\n");
}


int exploit_udp_sendmsg_test(){
  if(kern_version== 2 && kern_major == 6 && kern_minor <19){
    if(mmap_min_addr != 0){
      return 1;
    }
  }
  return 0;
}

void exploit_udp_sendmsg_info(){
  printf("udp_sendmsg might be possible\n");
  printf("\tEDB exploit: 9574,9575\n");
  printf("\t9574 needs also readable kallsyms but works in more environments\n");
}

int exploit_ia32_syscall_test(){
  if(kern_version== 2 && kern_major <= 6 && kern_minor <36){
    if(kern_x64==1)return 1;
  }
  return 0;
}

void exploit_ia32_syscall_info(){
  printf("syscall emulation exploit possible\n");
  printf("\tEDB exploit: 4460, 15023\n");
}

int exploit_RationalLove_test(){
  if( is_word_in_file("/etc/os-release","9 (stretch)") || 
      is_word_in_file("/etc/os-release","16.04.3 LTS (Xenial Xerus)") ||
      is_word_in_file("/etc/os-release","18.3 (Sylvia)") ){
    return 1;
  }
  return 0;
}

void exploit_RationalLove_info(){
  printf("Rational love exploit might be possible\n");
  printf("Keywords: CVE-2018-1000001\n");
  printf("\tEDB exploit: 43775\n");
}



int exploit_CVE_2017_6074_test(){
  if(kern_version >= 4 && kern_major >= 9) return 0; 
  int f = socket(PF_INET6, SOCK_DCCP, IPPROTO_IP);
  if( f == -1) return 0;
  close(f);
  return 1;
  return 0;
}

void exploit_CVE_2017_6074_info(){
  printf("Might be vulnerable to CVE-2017-6074 exploit.\n");
  printf("\tYou can try the trigger which causes DOS, EDB: 41457\n");
  printf("\tEDB: 41458\n");
  printf("\tHowever, for exploitation you need to get some addresses from kernel"); 
  if(readable_kallsyms == 0) printf(", which might be hard as kallsyms are not readable");
  printf("\n");
}

/*
Need to find which kernels are affected by this.
int exploit_CVE_2017_5123_test(){
}

void exploit_CVE_2017_5123_info(){
  printf("Might be vulnerable to CVE-2017-5123 exploit.\n");
  printf("\tYou might find many versions of this exploit online, with different bypassed\n");
  printf("\tEDB: 41458\n");
}


*/

int exploit_CVE_2017_7494_test(){
  if(is_word_in_command("smbd -V","3.5")) return 1;   
  if(is_word_in_command("smbd -V","3.6")) return 1;   
  if(is_word_in_command("smbd -V","4.0")) return 1;   
  if(is_word_in_command("smbd -V","4.1")) return 1;   
  if(is_word_in_command("smbd -V","4.2")) return 1;   
  if(is_word_in_command("smbd -V","4.3")) return 1;   
  if(is_word_in_command("smbd -V","4.4")) return 1;   
  if(is_word_in_command("smbd -V","4.5")) return 1;
  return 0;
}

void exploit_CVE_2017_7494_info(){
  printf("System might be vulnerable to CVE-2017-6494\n");
  printf("\tYou need valid credentials and writable folder in accessible share\n");
  printf("\tEDB: 42060\n");
  printf("\tMetasploit: is_known_pipename\n");
}

int exploit_CVE_2018_18955_test(){
  if(kern_version >= 4 && kern_major >= 15 && kern_major <=19) return 1;
  return 0;
}

void exploit_CVE_2018_18955_info(){
  printf("System might be vulnerable to CVE-2018-18955\n");
  printf("\tYou will need CAP_SYS_ADMIN\n");
  printf("\tEDB: 45886\n");
}

int exploit_uselib_test(){
  if(kern_version == 2 && ((kern_major == 4 && kern_minor == 4 && kern_minor <=29) || (kern_major == 6 && kern_minor >= 0 && kern_minor <=10 ))){
    FILE * fp = fopen("/proc/slabinfo","r");
    fclose(fp);
    if(fp == NULL)return 0;
    return 1;
  }
  return 0;
}

void exploit_uselib_info(){
  printf("System might be vulnerable to CVE-2004-1235\n");
  printf("\tEDB: 778\n");
}

int exploit_caps_to_root_test(){
  if(kern_version == 2 && kern_major == 6 && kern_minor >= 34 && kern_minor <= 36 && readable_kallsyms && !kern_x64){
    return 1;
  }
  return 0;
}

void exploit_caps_to_root_info(){
  printf("System might be vulnerable to caps_to_root\n");
  printf("Needs CAP_SYS_ADMIN\n");
  printf("\tEDB: 15916\n");
}


int exploit_cve_2005_0736_test(){
  if(kern_version == 2 && kern_major == 6 && kern_minor >= 5 && kern_minor <= 11){
    FILE * fp = fopen("/proc/cpuinfo","r");
    fclose(fp);
    if(fp == NULL)return 0;
    return 1;
  }
  return 0;
}

void exploit_cve_2005_0736_info(){
  printf("System might be vulnerable to CVE-2005-0736\n");
  printf("\tEDB: 1397\n");
}



int exploit_cve_2013_0268_test(){
  if((kern_version == 2 && kern_major == 6 && kern_minor >= 18 && kern_minor <= 39) || (kern_version == 3 && kern_major >=  0 && kern_major <= 7 && kern_x64) ){
    int msr_fd = open("/dev/cpu/0/msr", O_RDWR);
    if (msr_fd < 0) {
      msr_fd = open("/dev/msr0", O_RDWR);
      if (msr_fd < 0) {
        return 0;
      }
    }
    close(msr_fd);
    return 1;
  }
  return 0;
}

void exploit_cve_2013_0268_info(){
  printf("System might be vulnerable to CVE-2013-0268\n");
  printf("\tEDB: 27297\n");
}

int exploit_cve_2013_1763_test(){
  if((kern_version == 3&& kern_major >3  && kern_major <= 8 && readable_kallsyms ) ){
    int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_SOCK_DIAG);
    if(fd < 0)return 0;
    close(fd);
    return 1;
  }
  return 0;
}

void exploit_cve_2013_1763_info(){
  printf("System might be vulnerable to CVE-2013-1763\n");
  printf("\tEDB: 24555,24746,33336\n");
}


int exploit_half_nelson_test(){
  if((kern_version == 3&& kern_major >=0 && kern_major <= 36 && readable_kallsyms ) ){
    int sock = socket(PF_ECONET, SOCK_DGRAM, 0);
    if(sock < 0)return 0;
    close(sock);
    if(mmap_min_addr != 0) return 0;

    return 1;
  }
  return 0;
}

void exploit_half_nelson_info(){
  printf("System might be vulnerable to Half Nelson\n");
  printf("\tEDB: 17787\n");
} 

int exploit_cve_2017_16939_test(){
  if((kern_version < 4) || (kern_version == 4 && kern_major <13 || (kern_version == 4 && kern_major == 13 && kern_minor < 11)) ){
    int sock = socket(PF_NETLINK,SOCK_RAW,NETLINK_XFRM);
    if(sock < 0)return 0;
    close(sock);
    return 1;
  }
  return 0;
}

void exploit_cve_2017_16939_info(){
  printf("System might be vulnerable to CVE-2017-16939\n");
  printf("\tEDB: 44049 \n");
} 


int exploit_cve_2010_3904_test(){
  if(kern_version==2 && kern_major == 6 && kern_minor >= 30 && kern_minor <= 36 && readable_kallsyms){
    int sock = socket(PF_RDS, SOCK_SEQPACKET, 0);
    if(sock < 0)return 0;
    close(sock);
    return 1;
  }
  return 0;
}

void exploit_cve_2010_3904_info(){
  printf("System might be vulnerable to CVE-2010-3904\n");
  printf("\tEDB: 15285 \n");
} 


int exploit_ASL_test(){
  if(kern_version==2 && kern_major == 6 && kern_minor < 38 && readable_kallsyms){
    struct stat sb;
    int ret = stat("/sys/kernel/debug/acpi/custom_method",&sb);
    if (ret < 0 ||!(sb.st_mode & S_IWOTH)) {
      return 0;
    }
    return 1;
  }
  return 0;
}

void exploit_ASL_info(){
  printf("System might be vulnerable to American Sign Language\n");
  printf("\tEDB: 15774 \n");
} 


int exploit_exit_notify_test(){
  if(kern_version==2 && kern_major == 6 && kern_minor >= 25 && kern_minor <= 29){
    FILE * f = fopen("/proc/sys/fs/suid_dumpable","r");
    if(!f)return 0;
    int x;
    fscanf(f,"%d",&x);
    if(x==0)return 0;
    fclose(f);
    struct stat sb;
    int ret = stat("/etc/logrotate.d",&sb);
    if(ret < 0)return 0;
    return 1;
  }
  return 0;
}

void exploit_exit_notify_info(){
  printf("System might be vulnerable to exit_notify exploit (CVE-2009-1337)\n");
  printf("\tEDB: 8369 \n");
} 


int exploit_vmsplice_test(){
  if(kern_version==2 && kern_major == 6 && kern_minor >= 23 && kern_minor <= 24 && readable_kallsyms){
    return 1;
  }
  return 0;
}

void exploit_vmsplice_info(){
  printf("System might be vulnerable to vmsplice exploit (CVE-2008-0600)\n");
  printf("\tEDB: 5093 \n");
} 


int exploit_cve_2017_16995_test(){
  if(kern_version==4 && kern_major >=4 && kern_major <= 13){
    return 1;
  }
  return 0;
}

void exploit_cve_2017_16995_info(){
  printf("System might be vulnerable to CVE-2017-16995 \n");
  printf("\tEDB: 45010 \n");
} 

void try_exploits(){
  REGISTER_EXPLOIT(sock_sendpage);
  REGISTER_EXPLOIT(full_nelson);
  REGISTER_EXPLOIT(dirty_cow);
  REGISTER_EXPLOIT(pipe_c);
  REGISTER_EXPLOIT(CVE_2017_1000112);
  REGISTER_EXPLOIT(reiserfs_xattr);
  REGISTER_EXPLOIT(udp_sendmsg);
  REGISTER_EXPLOIT(ia32_syscall);
  REGISTER_EXPLOIT(RationalLove);
  REGISTER_EXPLOIT(CVE_2017_6074);
  REGISTER_EXPLOIT(CVE_2017_7494);
  REGISTER_EXPLOIT(CVE_2018_18955);
  REGISTER_EXPLOIT(uselib);
  REGISTER_EXPLOIT(caps_to_root);
  REGISTER_EXPLOIT(cve_2005_0736);
  REGISTER_EXPLOIT(cve_2013_0268);
  REGISTER_EXPLOIT(cve_2013_1763);
  
  REGISTER_EXPLOIT(half_nelson);
  REGISTER_EXPLOIT(cve_2017_16939);

  REGISTER_EXPLOIT(cve_2010_3904);
  REGISTER_EXPLOIT(ASL);

  REGISTER_EXPLOIT(exit_notify);
  REGISTER_EXPLOIT(vmsplice);

  REGISTER_EXPLOIT(cve_2017_16995);

  generated_exploits();
}
